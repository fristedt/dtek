1.1
30 bitar, eftersom 1 Gbyte = 2^30 bytes.

1.2
Storlek: 32 kbytes.
Blockstorlek: 32 bytes.
Associativitet: 1, eftersom cache-minnet är direktmappat.
Rutstorlek = Storlek.
Antalet bitar som inte används till tag är 15 bitar eftersom 32 kbytes = 2^15 bytes.
Byte-offset: 5 bitar, eftersom 32 bytes = 2^5 bytes.
Index: 10 bitar, eftersom 15 - 5 = 10.
Antalet rader: 1024, eftersom vårt index är 10 och 2^10 = 1024.
Resterande bitar går till taggen; 32 - 10 - 5  = 17.

---------------------------------------------------------
|V|Tag                         |Index       |Byte-offset|
| |17 bitar                    |10 bitar    |5 bitar    |
---------------------------------------------------------

1.3
Storlek: 64 bytes.
Blockstorlek: 8 bytes.
Associativitet: 1.
Rutstorlek = Storlek.
Antalet bitar som inte används till tag är 6 eftersom 64 bytes = 2^6 bytes.
Byte-offset: 3 bitar, eftersom 8 bytes = 2^3 bytes.
Index: 3 bitar, eftersom 6 - 3 = 3.
Antalet rader: 8.
Tag: 32 - 6 = 26 bitar.

---------------------------------------------------------
|V|Tag                         |Index       |Byte-offset| x 8
| |26 bitar                    |3 bitar     |3 bitar    |
---------------------------------------------------------

1.4
Varje rad i minnesmatrisen innehåller 1 validbit, 25 bitar för adressetiketten,
3 bitar för index och 3 bitar för byte-offset. 

Validbiten används för att kontrollera om raden innehåller korrekt information.
Indexbitarna används för att peka ut 1 av 8 rader i cacheminnet.
Byte-offsetbitarna används för att peka ut 1 av 8 bytes i raden.
Tag används för att kontrollera att det som är skrivet på den valda raden
verkligen motsvarar det sökta värdet i minnet.

1.5
Antalet bitar som inte används till tag kommer att behova ökas, eftersom vi nu
kommer behova 8 bitar för att peka ut en given byte i cachen ty 256 bytes = 2^8
bytes. Byte-offset lär bli oförändrad eftersom blockstorleken är orörd. Antalet
indexbitar kommer behöva ökas till 5 eftersom 8 (antalet icke-tag bitar) - 3
(byte-offset bitar) = 5. Det innebär att antalet rader kommer bli 2^5 = 32. Vårt
tagfält kommer att använda resterande bitar; 32 - 8 = 24.

---------------------------------------------------------
|V|Tag                         |Index       |Byte-offset| x 32
| |24 bitar                    |5 bitar     |3 bitar    |
---------------------------------------------------------

1.6
Antalet byte-offset bitar blir 5 eftersom 32 bytes = 2^5 bytes. Antalet
indexbitar förändras inte eftersom vi inte har några nya rader. Resterande bitar
går till taggen.

---------------------------------------------------------
|V|Tag                         |Index       |Byte-offset| x 8
| |24 bitar                    |3 bitar     |5 bitar    |
---------------------------------------------------------

1.7
Vi kommer få 4 rutor som delar på den totala storleken. Varje ruta kommer däför
rymma 64 / 4 = 16 bytes. Antalet icke-tag bitar kommer att bli 4, eftersom varje
ruta kommer rymma 16 olika bytes och vi vill kunna peka ut samtliga. Eftersom vi
fortfarande har blockstorlek 8 behöver vi fortfarande 3 bitar till byte-offset.
Därför måste antalet indexbitar bli 1. Antalet bitar till taggen kommer att bli
32 - 4 = 28 bitar. Antalet rader kommer bli 2^1 = 2.

-----------------------------------  -----------------------------------
|V|Tag      |Index    |Byte-offset|  |V|Tag      |Index    |Byte-offset| x 2
| |28 bitar |1 bitar  |3 bitar    |  | |28 bitar |1 bitar  |3 bitar    |
-----------------------------------  -----------------------------------

================================================================================

2.1
Instruktionscacheminnet.

2.2
Instruktionscacheminnet.

2.3
För att få mätvärden som är så bra som möjligt bör du räkna ut vilket
cacheminne som har flest missar multiplicerat med antalet klockcykler en miss
orsakar. Detta bör ge den totala tiden som cachemissar orsakar. Det minne med
det högsta värdet bör styra inställningen av miss penalty.

2.4
Du behöver aldrigt skriva till instruktionscacheminnet eftersom när programmet
är kompilerat och startat kommer instruktionerna inte ändras. Ett självklart
undantag till detta är självmodifierande kod, men det används inte tillräckligt
ofta för att justifiera speciella åtgärder vid designen av cacheminnet.

================================================================================

3
Nummer 3: 5553 / 283 ~= 19.62
Nummer 4: 7508 / 283 ~= 26.53

3.1
Instruktioner till simulatorn är 32 bitar = 4 bytes. Om cachen är 64 bytes
kommer alltså 16 instruktioner rymmars i cachen. Vi vet också att vår loop
kräver 18 instruktioner. Den ryms alltså inte i cachen och det är troligtvis
därför vi får så låg hit rate.

3.2
Nummer 2 och nummer 5. Nummer 5 har lägre körtid än nummer 2, men eftersom deras
hit rate i instruktionscacheminnet är samma måste minskningen av körtid komma
från andra håll.

3.3
Eftersom hela loopen ryms redan då instruktionscachen har storlek 4 * 18 = 72
bytes så ger ytterligare storleksökningar ingen förbättrad hit rate. 

================================================================================

4.1
Nej, eftersom samma instruktion inte utförs flera gånger.

4.2
Ja, programmet har bra rumslokalitet eftersom varje instruktion ligger precis
efter den föregående i minnet. Det innebär att när cacheminnet hämtar ett block
från minnet kommer cachen att få flera cacheträffar som följd.

4.3
När första instruktionen hämtas kommer det givetvis att bli en cachemiss. Då
hämtas ett block med storlek 8 bytes. 8 bytes rymmer två instruktioner. Nästa
instruktion som hämtas kommer därför att finnas i cachen. Efter det blir det
miss igen eftersom endast två instruktioner hämtades. Programmets hit rate bör
därför bli 50%.

================================================================================

5.1
Kolumnindex.

5.2
Instruktionscachen har en så hög hit rate eftersom den största delen av
programmet består av loopar; programmet visar hög tidslokalitet för
instruktioncachen. Datacachen har en så låg hit rate eftersom vi inte använder
samma adress i minnet varje iteration; dålig tidslokalititet. 

5.3
Instruktionscachen har en så hög hit rate eftersom nästan hela programmet består
av loopar. Strcpy hade också loopar men inte till samma grad som matris.

5.4
Eftersom simulatorn inte kan hantera olika accesstider för instruktioncachen
och datacachen måste vi anpassa vår access time efter den cache som har flest
missar. Eftersom instruktioncachen har en hit rate på 100% och datacachen har en
hit rate på 1% måste vi givetvis ställa access time efter vår datacache.

Datacachen har en blockstorlek på 2 ord. Att läsa det första ordet kommer att ta
3 processorklockcykler. Det andra ordet kommer att ta 1 processorklockcykel.
Enligt antaganden i labbinstruktionerna så arbetar vi med en processor med
klockfrekvens 2GHz och ett primärminne med 2MHz. Alltså arbetar processorn 10
gånger snabbare än primärminnet. Den totala tiden det kommer ta att läsa 2 ord
blir därför 30+10 = 40 processorklockcykler.

Medeltiden för att läsa ett ord till data cachen blir därför 40 / 2 = 20
processorklockcykler. Därför är vår access time 20.
