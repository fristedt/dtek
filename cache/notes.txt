1.1
30 bitar, eftersom 1 Gbyte = 2^30 bytes.

1.2
Storlek: 32 kbytes.
Blockstorlek: 32 bytes.
Associativitet: 1, eftersom cache-minnet är direktmappat.
Rutstorlek = Storlek.
Antalet bitar som inte används till tag är 15 bitar eftersom 32 kbytes = 2^15 bytes.
Byte-offset: 5 bitar, eftersom 32 bytes = 2^5 bytes.
Index: 10 bitar, eftersom 15 - 5 = 10.
Antalet rader: 1024, eftersom vårt index är 10 och 2^10 = 1024.
Resterande bitar går till taggen; 32 - 10 - 5  = 17.

---------------------------------------------------------
|V|Tag                         |Index       |Byte-offset|
| |17 bitar                    |10 bitar    |5 bitar    |
---------------------------------------------------------

1.3
Storlek: 64 bytes.
Blockstorlek: 8 bytes.
Associativitet: 1.
Rutstorlek = Storlek.
Antalet bitar som inte används till tag är 6 eftersom 64 bytes = 2^6 bytes.
Byte-offset: 3 bitar, eftersom 8 bytes = 2^3 bytes.
Index: 3 bitar, eftersom 6 - 3 = 3.
Antalet rader: 8.
Tag: 32 - 6 = 26 bitar.

---------------------------------------------------------
|V|Tag                         |Index       |Byte-offset| x 8
| |26 bitar                    |3 bitar     |3 bitar    |
---------------------------------------------------------

1.4
Varje rad i minnesmatrisen innehåller 1 validbit, 25 bitar för adressetiketten,
3 bitar för index och 3 bitar för byte-offset. 

Validbiten används för att kontrollera om raden innehåller korrekt information.
Indexbitarna används för att peka ut 1 av 8 rader i cacheminnet.
Byte-offsetbitarna används för att peka ut 1 av 8 bytes i raden.
Tag används för att kontrollera att det som är skrivet på den valda raden
verkligen motsvarar det sökta värdet i minnet.

1.5
Antalet bitar som inte används till tag kommer att behova ökas, eftersom vi nu
kommer behova 8 bitar för att peka ut en given byte i cachen ty 256 bytes = 2^8
bytes. Byte-offset lär bli oförändrad eftersom blockstorleken är orörd. Antalet
indexbitar kommer behöva ökas till 5 eftersom 8 (antalet icke-tag bitar) - 3
(byte-offset bitar) = 5. Det innebär att antalet rader kommer bli 2^5 = 32. Vårt
tagfält kommer att använda resterande bitar; 32 - 8 = 24.

---------------------------------------------------------
|V|Tag                         |Index       |Byte-offset| x 32
| |24 bitar                    |5 bitar     |3 bitar    |
---------------------------------------------------------

1.6
Antalet byte-offset bitar blir 5 eftersom 32 bytes = 2^5 bytes. Antalet
indexbitar förändras inte eftersom vi inte har några nya rader. Resterande bitar
går till taggen.

---------------------------------------------------------
|V|Tag                         |Index       |Byte-offset| x 8
| |24 bitar                    |3 bitar     |5 bitar    |
---------------------------------------------------------

1.7
Vi kommer få 4 rutor som delar på den totala storleken. Varje ruta kommer däför
rymma 64 / 4 = 16 bytes. Antalet icke-tag bitar kommer att bli 4, eftersom varje
ruta kommer rymma 16 olika bytes och vi vill kunna peka ut samtliga. Eftersom vi
fortfarande har blockstorlek 8 behöver vi fortfarande 3 bitar till byte-offset.
Därför måste antalet indexbitar bli 1. Antalet bitar till taggen kommer att bli
32 - 4 = 28 bitar. Antalet rader kommer bli 2^1 = 2.

-----------------------------------  -----------------------------------
|V|Tag      |Index    |Byte-offset|  |V|Tag      |Index    |Byte-offset| x 2
| |28 bitar |1 bitar  |3 bitar    |  | |28 bitar |1 bitar  |3 bitar    |
-----------------------------------  -----------------------------------

2.1
Instruktionscacheminnet.

2.2
Instruktionscacheminnet.

2.3
För att få mätvärden som är så bra som möjligt bör du räkna ut vilket
cacheminne som har flest missar multiplicerat med antalet klockcykler en miss
orsakar. Detta bör ge den totala tiden som cachemissar orsakar. Det minne med
det högsta värdet bör styra inställningen av miss penalty.

2.4
Du behöver aldrigt skriva till instruktionscacheminnet eftersom när programmet
är kompilerat och startat kommer instruktionerna inte ändras. Ett självklart
undantag till detta är självmodifierande kod, men det används inte tillräckligt
ofta för att justifiera speciella åtgärder vid designen av cacheminnet.


